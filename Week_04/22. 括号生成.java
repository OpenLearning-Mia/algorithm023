




// 国内most vote   
// 解法：回溯，dfs
// 三点思维认知：

/*  1.题目求的n对括号的排列组合情况有哪些？这种排列组合问题用【树】的特性来实现
*   2.
*   3.
*   4.。
*
*   画出如上的树图，根据图分析，推荐，可知：

*/







/*
* 1.题目需求：
*	输入：括号的对数n；
*	输出：生成所有可能的 并且有效的 括号组合
*
* 2.解法：【深度优先遍历DFS】
*
* 3.解题思路：
*	3.1.看到求排列组合的，就用【树】特性实现
*
*	3.2.左右括号 对应树的左右儿子
*
*	3.3.最后的叶子节点就是答案
*
*	3.4.深度遍历到叶子答案，用DFS遍历来实现
*
*	3.5.有效括号的特性要求：先有左括号，然后才能有右括号(不能反着来)，有先后制约关系;
*
*	3.6.画出如上的树图，推演分析实现过程和规律;

*   3.7.根据画树图推演分析，可知：
*       - 当前左或右括号剩下的可用个数 大于0个时，才能产生分支；
*       - 产生左分支时：只看当前是否还有左括号可以使用
*       - 产生右分支时：受到左分支的限制(有效括号必须先有左，才能有右，右的存在 得匹配上左，否则无效)，
*       - 也就是【右剩余个数】必须【大于】【左剩余个数】才能产生【右分支】；否则（右剩余<=左剩余）不能产生分支，如果产生就是无效括号。
*       - 在左和右剩余括号数都等于0时，表示已递归到叶子节点(题目答案)，当前递归结束。
*
* 4.复杂度分析:
*   时间：O(n)；递归遍历所有树节点
*
*   空间：O(n)；n为括号对数，除了答案数组之外，我们所需要的空间取决于递归栈的深度，
*              每一层递归函数需要O(1) 的空间，最多递归2n层，因此空间复杂度为 O(n)
*
 */

/* 有效括号在被分配的过程中，判断是否有效的条件：左剩余个数应【小于】右剩余个数，否则就是无效括号
   最后左右剩余个数都为0,表示左右括号都被分配完了。
*/

public class Solution {

    // 括号使用，做减法：用一个减一个，减到0表示括号用完了，找到答案了；

    public List<String> generateParenthesis(int n) {
        List<String> res = new ArrayList<>();   //res用来存结果集合
        // 特判：括号对数为0，return null
        if (n == 0) {
            return res;
        }

        // 执行 深度优先遍历，搜索可能的结果
        dfs("", n, n, res);
        return res;
    }

    /**
     * @param curStr 用来存 当前递归得到的一个结果
     * @param left   左括号还剩几个可用
     * @param right  右括号还剩几个可用
     * @param res    结果集
     */

    // 递归，dfs
    private void dfs(String curStr, int left, int right, List<String> res) {

        // 1.递归结束条件：左右括号都用完了，递归找到了叶子节点(答案)，递归当前递归结束；
        if (left == 0 && right == 0) {
            res.add(curStr);  //存储当前递归结果
            return;
        }

        // 2.处理当前层：剪枝，需要去掉不符合要求的【右分支】(无效括号，右括号剩余可用个数 <= 左剩余剩余可用个数)
        if (left > right) {
            return;
        }

        // 3.深入下一层递归
        //   先左后右(有效括号的特性：先有左括号，才能有右括号；其左右有先后制约关系)
        if (left > 0) {
            dfs(curStr + "(", left - 1, right, res);
        }
        if (right > 0) {
            dfs(curStr + ")", left, right - 1, res);
        }
    }
}




// 2021年1月19日16:59:43

// most vote
// https://leetcode-cn.com/problems/generate-parentheses/solution/hui-su-suan-fa-by-liweiwei1419/
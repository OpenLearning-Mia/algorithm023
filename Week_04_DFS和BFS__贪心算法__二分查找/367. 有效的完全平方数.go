// 2021年1月23日10:24:56

// 数学和逻辑果然是算法的基石，牛逼.      (网友评论)

/*
* 做题感受总结：先搞清楚基本概念问题啊，比如【啥叫完全平方数】？
*			   搞清楚基本概念后 再推演分析、找思路和解决方案。
*			   误区：不要一上来就着急找答案，基本概念都没弄懂啊，这会导致舍本求末，事倍功半。
*			   搞清楚【问题本质是什么】很重要。它是基石，是【做成事情的前提条件】。
*
* 1.题目需求：
*	输入：一个正整数num（num > 0）
*	输出：如果 num 是一个完全平方数，则返回 True，否则返回 False。
*
* 2.解法：二分查找
*
* 3.解题思路：
*
*	3.1.啥叫完全平方数？: 一个数x使得num = x²，则num就是完全平方数。
*
*	3.2.num = x²相当于 y = x²；
*
*	3.3.由于函数y = x²是一个单调函数，【符合二分查找条件：单调有序性】，所以可以用二分查找去做。
*
*	3.4.接下来重要的一点是:要确认出二分查找目标的【取值范围】，确认完后就可以开始二分查找结果了；
*
*	3.5.根据题目信息可知: 二分查找的下界为1，关键点在【上界的确定】：
*		可以粗略定位num,但是仔细推导发现，可以定位num/2;这样就缩小一半的查找区间了。优化；
*	3.6.是如何确定出二分查找的上界为num/2？？首先是推导演练num = x²的规律:x=1,2,3下的num值；
*		然后由num = x²可知: x <= num/2(其中num!=1, num>1,可验证演练出来)。
*		如此，得出二分查找目标x的取值范围为[2,num/2],其中num>1；
*		（另一种写法，就是把num=1的情况包含进去，得查找范围为[1,num/2+1]，也就是查找内容多了两个：1和num/2+1）

*
*	3.7.在二分查找的每一步中，我们只需要比较中间元素mid的平方与x的大小关系，通过比较的结果不断缩小上下界的范围，直到找到答案。
*
*	3.8.【编码隐患】：整型数相加或相乘后的【结果溢出问题】：
*		 1.mid = (right + left)/2、mid*mid>x，如果right、left、mid值非常大（eg: 2^31-1），最后都可能导致计算结果溢出（right + left、mid*mid）
*		 2.所以安全的写法是：mid = left + (right - left)/2 和 (mid > x/mid && num%mid==0)；
*		   或者使用【位运算】：mid = left + ((right - left) >> 1)；因为cpu处理位运算更快。
**		update:再或者把结果变量定义成long型，因为计算的元素是int型(4 byte,long型：32bit:4byte;64bit:8byte)，所以计算结果(long long型:8 byte)就不会产生溢出，就可以用mid*mid>x这种计算方式；
*
* 4.复杂度分析:
*
*   时间：O(logn)；二分查找次数;

*   空间：O(1)；常量空间
*
 */
func isPerfectSquare(num int) bool {
	// 1.防错处理，理应num>=1
	if num < 1 {
		return false
	}
	// 2.特判：num=1
	if num == 1 {
		return true
	}

	// 3.初始化：查找区间为[2, num/2]
	left, right := 2, num/2

	// 4.开始二分查找模式：小了，往右找；大了，往左找；最后要么找到了、要么没找到，return and func end;
	//   查找结束条件：left > right, (越界了，结束)
	for left <= right {
		mid := left + (right-left)/2
		if mid == num/mid && num%mid == 0 { //1.找到了
			return true
		}
		if mid < num/mid { //2.mid小了，往右找； 找更大的，使mid^2值接近于num
			left = mid + 1 //因为往右找，所以更新区间范围left

		} else { //3.mid大了，往左找； 找更小的，使mid^2值小于等于num
			right = mid - 1 //因为往左找，所以更新区间范围right
		}
	}
	//到这表示没有找到，num不是完全平方数
	return false
}

// 2021年1月23日12:35:08  2h
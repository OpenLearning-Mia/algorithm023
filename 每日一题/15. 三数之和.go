import "sort"

/*
* 1.题目需求：
*	输入：数组nums；其包含n个整数；
*	输出：nums中 是否存在 【三个元素 a，b，c】 ，使得 a + b + c = 0？
*		  找出 所有【和为0且不重复】的三元组；(答案中不可以包含重复的三元组)
*
*  不重复的三元组 是指：
*		我们枚举的三元组 (a, b, c)满足a≤b≤c，
*		保证了只有 (a, b, c)这个顺序会被枚举到，
*		而 (b, a, c)、(c, b, a) 等这些不会，这样就减少了重复。
*		要实现这一点，我们可以将数组中的元素从小到大进行排序，来跳过重复的。
*
* 2.解法：
*
* 3.解题思路：
*
*	3.1.
*
*	3.2.如上，按顺序枚举每一位可能出现的情况，这样的思路，可以用一个树形结构表示；
*
*	3.3.尝试自己亲手画出「全排列」问题的树形结构,增加感受体会，过一遍或多遍脑子，能更高效的、更好的 理解树，回溯，递归算法思想。
*	   （做题感受：需要画出和推演这个树图 来分析理解和编码，凭空想象无解，云里雾里，费脑不讨好）
*
*	3.4.使用编程的方法得到全排列，就是在这样的一个树形结构中完成遍历，从树的根结点到叶子结点形成的路径就是其中一个全排列。
*
*
* 3.复杂度分析:
*   时间：O(n)； 一共n!个叶子节点(全排列的所有情况，结果集)，
*		  每个叶子节点，需要O(n) 的时间复制到答案数组中，所以时间复杂度为O(n∗n!)，n为序列长度。
*
*   空间：O(n)；除答案数组(O(n))以外，递归函数在递归过程中需要为每一层递归函数分配栈空间，其需要额外的空间取决于递归的深度(deep = n)，所以空间复杂度为O(n)，n为序列长度。
*
* 5.做这题的感受总结：
*	做题的时候，需要动手画出推演过程，找出规律(没有看出来的过程和结果，只有亲自动手尝试体会才能理解透彻，明白问题本质)，
*	比如像回溯，递归，dfs等算法思想的题,先画树形图 ，画图能帮助我想清楚递归结构，看清楚回溯，dfs流程，理解其思想精髓。
*	大脑是用来思考的，不是用来存储或记忆的，多动手写出来，写出问题真实情况；不要塞在脑子里，否则脑子就没法 腾出空间思考和解决问题了。
 */

//  审题，分析，疑问记录：

//  是否存在三个元素，那0、1、2个元素的情况怎么认定？？输出为空？即便相加结果都是0，但是不是三个元素？
// 还有三个元素里，[0,0,0]算吗？答：算

/*
面试很多年轻前端同学的时候，他们会一上来就直接开始写代码，然后把草纸写得一团糟。我都会给他们讲，要把算法和编码分开来看，你可以用伪代码，画图，甚至摆弄小道具的方法去寻求解法。有了明确的解法，再转化成可执行的代码，就是水到渠成的事情了。

*/

/*
* 1.题目需求：
*	输入：数组nums；其包含n个整数；
*	输出：nums中 是否存在 【三个元素 a，b，c】 ，使得 a + b + c = 0？
*		  找出 所有【和为0且不重复】的三元组；(答案中不可以包含重复的三元组)
*
*  不重复的三元组 是指：
*		枚举的三元组 (a, b, c)满足a≤b≤c，
*		(a, b, c)、(b, a, c)、(c, b, a) 这些属于同一个答案，要去重。
*		通过将数组中的元素从小到大进行排序，来跳过重复。
*
* 2.解法：排序  双指针
*
* 3.解题思路：
*	题目意思：首先元素至少有三个，否则不满足条件，func直接返回；
*
*	特殊情况处理，如果数组长度为小于3（len=0,1,2），func立刻返回空。
*
*	3.1.题目需求要去除重复解（比如[1,-2,1],[-2,1,1]重复解）,所以先对数组排序，这样方便按序跳过重复的元素,
*		也利于后面【和】的判断提供信息：需要移动哪个指针。
*
*	3.2.将三数之和问题转化为两数之和问题，即-a = b+c, target=-a,
*
*	3.3.根据target,找出所有满足 b+c=target 的[b,c]解集合
*
*	3.4.b, c值 用左右指针来遍历查找：左右指针 向中间移动；两指针相遇时，遍历结束
*
*	3.5.b+c>target，说明c太大，减小c值，右指针 左移；
*
*	3.6.b+c<target,说明b太小，增加b值，左指针 右移
*
* 4.复杂度分析:
*
*   时间：O(n^2)；两层遍历嵌套，n为数组长度
*
*   空间：O(n)；结果数组空间
*
 */

func threeSum(nums []int) [][]int {


	n := len(nums)
	ans := make([][]int, 0) //ans用来存储 结果集合
	
	//特殊情况处理，如果数组长度为0或者数组长度小于 3，func立刻返回空。
	if n < 3 {
		return ans
	}


	// 1. 先给nums排序，为了后面 去除重复解 使用
	sort.Ints(nums)

	// 三元组[a,b,c]，即[nums[first], nums[second], nums[third]], 其中second，third为左右指针

	// -a做为target值，遍历元素a，找出所有满足 b+c=target 的[b,c]解集合
	for first := 0; first < n; first++ {

		// 优化点：如果a大于0，则a+b+c一定大于0,func返回；
		if nums[first] > 0 {
			return ans
		}

		// 2.target值需要和上一次枚举的数old_target不相同(题目要求是 无重复的结果)
		if first > 0 && nums[first] == nums[first-1] {
			continue
		}

		// 3.初始化 右指针third，target
		third := n - 1             // c对应的右指针 初始指向数组尾部
		target := -1 * nums[first] // -a表示target

		// 4.遍历元素b
		for second := first + 1; second < n; second++ {

			// 4.1.左指针向右遍历时 要跳过重复值(题目要求是 无重复的结果)：b需要和上一次枚举的数old_b不相同
			if second > first+1 && nums[second] == nums[second-1] {
				continue
			}

			// 4.2.需要保证左指针 在 右指针 的左侧 (如果左右指针重逢，则遍历结束)
			for second < third && nums[second]+nums[third] > target {
				third-- //表示b,c之和 太大(大于target了，需求是：等于target)，需要减小c的值(c向左移)
			}

			// 4.3. b,c指针重合了，则遍历结束
			if second == third {
				break
			}

			// 4.4.到这里表示找到了 一组[a,b,c],满足题目需求(b + c = -a)，存入数组ans
			if nums[second]+nums[third] == target {
				ans = append(ans, []int{nums[first], nums[second], nums[third]})
			}

			// 4.5.到这里表示：存完答案后，接下来，继续寻找【新的b,c】(此时taget没变，还是之前的值)

		} //end for2

	} //end for1
	return ans
}

/*
* 	三元组：[a,b,c]，其对应下标：[first,second,third]
*
*   【a+b+c=0】转化为【-a = b+c】,转化为TwoSum模型问题，
*	其中target = -a，即target = b+c;用左右指针来遍历b,c，找出b+c = target的情况；
*
*   双指针法：
*		1.first初始指向数组头部，first = 0
*		2.second为左指针，指向first的下一个元素；second = first + 1
*		3.third为右指针，指向数组尾部节点； third = n-1
*		4.左右指针 向中间移动；两指针相遇时，遍历结束。
 */




//  todo：3sum 这个题的空间复杂度到底是多少？？？？

空间复杂度不包括存储结果值而开辟的空间？？？？

这个事需要确认，重要！

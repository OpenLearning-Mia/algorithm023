

/*
* 题目需求：把字符串 s 中的每个空格替换成"%20"
*
* 1.解法：双指针倒序遍历，原地扩容
*   
* 2.思路分析：
*	2.1.先遍历出空格个数为count，然后对s扩容：新增2*count空间	
*
*	2.2.然后倒序遍历字符串，用双指针遍历，指针指向初始化：
*	    【左指针】指向原字符串最后一个元素，【右指针】指向数组尾部空间。
*
*	2.3.两指针同时向左(数组头部)遍历移动，遇到字符往后挪，遇到空格填充%20；
*		2.2.1.【倒序遍历优点】：每个字符最多被挪动一次(与正序遍历相比)，降低时间复杂度；
*
*	2.4.遍历结束条件：i==j（两指针重合，表示左边已无空格，空格都被填充完了，func end）
*
*	解题流程简化(第二遍)：1.算出空格个数count，扩容2*count；
*			 2.双指针，倒序遍历。左指向字符串最后一个元素，右指向数组尾部元素空间
*			 3.左右同时向左遍历，遇到字符往后挪，遇到空格填充%20;
*			 4.指针遍历结束条件：两指针重合(i==j),表示左边已无空格，填充结束
*
* 3.复杂度分析:
*   时间：O(n)，其中 n 为字符个数，每个字符最多被遍历和挪动一次
*   空间：O(2m)，等于O(m)，m表示空格个数；
*
*/ 
// c++ 
class Solution {
	public:
		string replaceSpace(string s) {
			
			int count = 0, len = s.size();
			// 0.特判：字符串长度为0
			if (len == 0) return s;

			// 1.统计空格数量
			for (char c : s) {
				if (c == ' ') count++;
			}

			// 2.扩容 数组s的长度
			s.resize(len + 2 * count);

			// 3.倒序遍历修改；妙点：倒序遍历，所以元素只用挪动一次(减少元素挪动次数，降低时间复杂度，和正序遍历相比)
			//	 初始情况下：s[i]指向原字符串的最后一个字符；s[j]指向新字符串空间的最后一个空间  
			for(int i = len - 1, j = s.size() - 1; i < j; i--, j--) {
				// 3.1.当前字符为 非空格，后移
				if (s[i] != ' ')
					s[j] = s[i];

				else {
					// 3.2.当前字符为 空格，替换成%20；然后j向左移动三步，指向下一个字符空间
					s[j - 2] = '%';
					s[j - 1] = '2';
					s[j] = '0';
					j -= 2;
				}
			}
			return s;
		}
	};

// 2021‎年‎1‎月‎12‎日，‏‎13:06:05  第一遍



// 2021年1月31日23:17:49 第二遍
// todo疑问:
// 您好！请问如果用其他语言是不是不能实现方法二，也就是不额外建立新字符串不能完成？
//  嗯嗯，因为 Python Java 输入的 String 就是不可变的，所以无法避免重新建立字符串～
// 我的问题：go的String呢？也不能变？？需要确认;todo



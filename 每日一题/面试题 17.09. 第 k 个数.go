










/*
* 1.题目需求：
*	输入：k ；
*	输出：找出第 k 个数； 第 k 个数的值：要求满足 min(dp[p3] * 3, Math.min(dp[p5] * 5, dp[p7] * 7)) 这一形式
*
*  数的素因子只有 3，5，7
*
* 2.解法：动态规划
*
* 3.解题思路：
*
*	3.1. 1没有质因子，1与任何正整数（包括1本身）都是互质
*
*	3.2.设置1为第一位，dp[0] = 1;
*
*	3.3.初始化三个指针 p3，p5，p7指向第一个丑数1
*
*	3.4.在dp[p3]*3, dp[p5]*5,dp[p7]*7 中选取最小数字作为新的数字dp[i],并将该数字对应的指针向前移动一步
*
*	3.5.直到计算出dp[k-1]的数值，输出，func end；
*
*
* 4.复杂度分析:
*
*   时间：O(k)；k为数的个数; 计算k次
*
*   空间：O(k)；存储数的数组空间，k为数的个数
*
 */
class Solution {

    public int getKthMagicNumber(int k) {

        int p3 = 0, p5 = 0, p7 = 0;
		int[] dp = new int[k];
		
		dp[0] = 1;
		
        for( int i = 1; i < k; i++ ){
            // 选出最小的数字,作为新的数dp[i]
			dp[i] = Math.min(dp[p3] * 3, Math.min(dp[p5] * 5, dp[p7] * 7));
			
            // 将该数字对应的指针向前移动一步，接着计算出下一个数；
            if( dp[i] == dp[p3] * 3 ) p3++;
            if( dp[i] == dp[p5] * 5 ) p5++;
            if( dp[i] == dp[p7] * 7 ) p7++; 
        }
        return dp[k-1];  //获得了第k个数，func end
    }
}


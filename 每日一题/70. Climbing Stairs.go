








// 因为每次只能爬1级或2级



// 方法：斐波那切数列  滚动数组思想
// f(n)=f(n−1)+f(n−2)
// 复杂度：时间O(n); 空间O(1)



/* 
	本问题分成多个子问题，爬第n阶楼梯的方法数量，等于 2 部分之和
	1.爬上n−1阶楼梯的方法数量。因为再爬1阶就能到第n阶
	2.爬上n−2阶楼梯的方法数量，因为再爬2阶就能到第n阶

*/

/*
* 1.题目需求：
*	输入：n个台阶，n 为正整数(n > 0)；
*	输出：有多少种不同的方法 可以爬到楼顶？（计算出n个台阶的爬法数量）
*   
*	附加条件：每次只能爬 1 或 2 个台阶 
*
* 2.解法：斐波那切数列  滚动数组思想
*
* 3.解题思路：
*	3.1.本问题分成多个子问题，爬第n阶楼梯的方法数量，等于两部分之和：
*		1.爬上n−1阶楼梯的方法数量。因为再爬1阶就能到第n阶;
*		2.爬上n−2阶楼梯的方法数量，因为再爬2阶就能到第n阶。
*
*	3.2.如此，问题转化为求斐波那切数列，f(n)=f(n−1)+f(n−2)
*
*	3.3.使用 滚动数组思想，来更新f(n)、f(n−1)、f(n−2)三个数的值
*
* 4.复杂度分析:
*   时间：O(n)；遍历计算n次
*   空间：O(1)；常量空间大小
 */
public int climbStairs(int n) {
    // 1.n为一个台阶、二个台阶时的爬法数量
    if(n == 1) return 1;
    if(n == 2) return 2;

	// 2.初始化
	int first = 1;
    int second = 2;
    int third = 0;
	
	// 3.从n=3开始，根据斐波那切数列规律：f(n)=f(n−1)+f(n−2)
	//   计算出n个台阶的爬法：third = second + first 
    for(int i = 3; i <= n; i++) {

		// 3.1.计算出i个台阶的爬法数third
		third = second + first;
		
		// 3.2.更新second、first值，为计算(i+1)个台阶的爬法数做准备（滚动数组思想）
    	first = second;
        second = third;
	}
	// 4.到这表示已计算出n个台阶的爬法数third
    return third;
}





















// go语言版
func climbStairs(n int) int {
	if n == 1
		return 1;
	if n == 2
		return 2;

----------------------------
    p, q, r := 0, 0, 1
    for i := 1; i <= n; i++ {
        p = q
        q = r
        r = p + q
    }
    return r
}





// todo: 动态规划的概念是啥？？？啥叫动态规划？？？上面的题解方法是动态规划吗？？？
// 2021年1月19日19:48:28







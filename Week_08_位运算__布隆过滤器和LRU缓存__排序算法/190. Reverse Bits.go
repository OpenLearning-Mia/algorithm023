// 2021年2月22日10:30:46

// 题目: 颠倒 给定的 32 位无符号整数的二进制位。

// 题目的需求：
// 我的理解和翻译：颠倒 就是反转，参考反转链表的效果；eg:1-2-3 反转：3-2-1
// 题目要求的反转对象：32位二进制数(32位全反转)










/* 
方法一：逐位颠倒
    关键思想是：对于位于索引 i 处的位，在反转之后，其位置应为 31-i（注：索引从零开始）
    即关键点：【题目规律：第i位 对应 第(31-i)位】；画出这个对应关系图来，推演分析，会更直观、更好地理解它的意思和规律（事半功倍）；

网友：
有必要说那么复杂吗？
简单点就是循环32次，每次获取最后一位,也就是n&1，与结果（初始为0）相或（res=n&1|res），再将n右移，结果左移。 最终的结果就是反转的数了。具体看代码，可能表达不是很好。
举个例子：00001010->01010000 8位还是32位都一样。

*/
func reverseBits(num uint32) uint32 {
    ret := uint32(0)  //存储翻转后的二进制数(每一位，翻转一次，ret就累加一次，直到最后num的32位全部翻转完毕，此时ret为最终答案)；
    power := uint32(31)  //表示num最低位要左移几次，第i位对应第(31-i)位，即第i位的值要翻转到第(31-i)位上（翻转动作）
    
    //翻转结束条件：num=0，表示num右移了32次(num已变为0)，它的32位都已被翻转完毕
    for num != 0 {
        ret += (num & 1) << power  //ret累加每次翻转后的结果，累加完32次完毕，得出最终答案；
        num = num >> 1  //num右移一位，目的是为num的下一个最低位反转做准备。可手工推演分析过程，能更好的理解它的规律和过程。
                        // num不断的往右移；其高位不断的在填充0，直到num32bit全是0（num值为0），表示反转结束
        power -= 1  //表示左移(反转)几位，起始power=31，表示左移31位；从右往左移，也就是从右往左反转。
    }
    return ret
}

//  运算符优先级问题：加号+的优先级 大于 位与&的优先级，后面一个应该写成ans = ans + (n & 1)

// (num & 0..0001)  获取num的最低位（右边）

// (num & 1) << power  num的最低位(第0位)左移31位（翻转操作，关键点：第i位 对应 第(31-i)位），移完后第0位的值正好落在第31位上。

// ret为 每次位移(翻转)后的累加值, 也是最终的反转结果。

// 复杂度分析：
// 时间: O(1); 循环32次；常数级
// 空间: O(1)
// 因为一共只有32位，所以时间复杂度和空间复杂度都是O(1)

// 做题感受总结：画出这个过程图来，推演分析，会更直观、更好地理解它的意思和规律（事半功倍）；
//              如果光看文字和代码，理解很费劲，不知道它啥意思，为啥要这样做？费力不讨好效果不好。
//            【有行动，才有感受，有感受，才能知道它啥意思，最后才会知行合一，认知内化】，行动产生感知力，感知力加强认知，加强知行合一。

// 2021年2月22日16:03:50






// 不使用循环，反转整个32位 （用分治思想+位操作 来实现）
// 在这里，我们提出了一种只使用位操作的解决方案。
// 这种思想可以看作是一种分治的策略，我们通过掩码将 32 位整数划分成具有较少位的块，然后通过将每个块反转，最后将每个块的结果合并得到最终结果。
func reverseBits(num uint32) uint32 {
    
    num = (num >> 16) | (num << 16)

    num = ((num & 0xff00ff00) >> 8) | ((num & 0x00ff00ff) << 8)
    num = ((num & 0xf0f0f0f0) >> 4) | ((num & 0x0f0f0f0f) << 4)
    num = ((num & 0xcccccccc) >> 2) | ((num & 0x33333333) << 2)
    num = ((num & 0xaaaaaaaa) >> 1) | ((num & 0x55555555) << 1)
    return num
}

// 0xcccccccc: 1100 1100 1100 1100 ...1100 分解成2bit的子问题；最后分解成1bit的子问题；

1.num & 0xff00ff00：   这是要干嘛？为啥这么做？？想 
2.(num & 0xff00ff00) >> 8：  

3.num & 0x00ff00ff: 
4.(num & 0x00ff00ff) << 8


原：a b c d
对半分，翻转：c d__a b
在对c d__a b对半分并翻转：d c b a，分成单个元素的，就不能再分了，到底了，d c b a是最终答案；


1.num & 0xff00ff00和位移8，4，3这种与的方式，就是在做 分治、对半分解成子问题的工作
2.>> 8 、 >> 4 这些位移就是在进行翻转操作；
3.分支结束条件：已分解成【单个bit位】了，单个bit位相邻之间交换下位置，汇总这些子结果，就实现最终的翻转答案了


如下分解过程：(分治思想)
a b c d
 /   \
c d  a b
/ \  / \
d  c b  a  最终的翻转结果

过程：边分解成 两个子问题、边翻转两个子问题

复杂度分析：
    时间复杂度：O(1)，没有使用循环。
    空间复杂度：O(1)，没有使用变量


// 2021年2月22日20:02:50 first done